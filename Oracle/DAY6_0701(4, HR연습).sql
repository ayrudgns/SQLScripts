-- HR 스키마를 이용한다.
-- JOIN과 GROUP BY를 포함해서 SELECT로 검색하는 문제를 10개 만들기

-- 작성자 : juleeus
-- 주석으로 검색하는 내용 쓰고, SELECT 쿼리 작성하기

-- 1. REGIONS과 COUNTRIES를 JOIN하고 컬럼의 중복 없이 모든 컬럼을 REGION_NAME 오름차순으로 조회하기
SELECT R.REGION_ID, REGION_NAME, COUNTRY_ID, COUNTRY_NAME FROM REGIONS r, COUNTRIES c
	WHERE R.REGION_ID = C.REGION_ID ORDER BY REGION_NAME;

-- 2. FIRST_NAME이 'Jennifer'인 직원의 START_DATE와 HIRE_DATE 조회하기 (대소문자 구별)
SELECT START_DATE, HIRE_DATE FROM EMPLOYEES e, JOB_HISTORY jh
	WHERE E.EMPLOYEE_ID = JH.EMPLOYEE_ID
	AND FIRST_NAME = 'Jennifer';

-- 3. DEPARTMENT_ID가 90인 직원의 EMPLOYEE_ID, PHONE_NUMBER, MANAGER_ID 조회하기
SELECT EMPLOYEE_ID, PHONE_NUMBER, D.MANAGER_ID FROM EMPLOYEES e, DEPARTMENTS d
	WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
	AND D.DEPARTMENT_ID = 90;

-- 4. JOBS와 JOB_HISTORY를 OUTER JOIN하여 컬럼의 중복 없이 모든 컬럼을 조회하기 (중복되는 컬럼은 부모 컬럼 기준으로 조회)
SELECT J.JOB_ID, JOB_TITLE, MIN_SALARY, MAX_SALARY, EMPLOYEE_ID, START_DATE, END_DATE 
	FROM JOBS j LEFT OUTER JOIN JOB_HISTORY jh ON J.JOB_ID = JH.JOB_ID;
	
-- 5. EMPLOYEES, DEPARTMENTS, LOCATIONS를 JOIN하여 대문자 'V'로 시작하는 EMAIL만 조회하기
SELECT EMAIL FROM EMPLOYEES e, DEPARTMENTS d, LOCATIONS l
	WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID AND D.LOCATION_ID = L.LOCATION_ID
	AND EMAIL LIKE 'V%'; 

-- 6. EMPLOYEES를 JOB_ID에 대하여 그룹화하고 JOB_ID, 각 그룹의 EMPLOYEE의 수, 최고 SALARY, 최저 SALARY 조회하기
-- (COUNT 내림차순 정렬)
SELECT JOB_ID, COUNT(*) EMPLOYEE_CNT, MAX(SALARY), MIN(SALARY) FROM EMPLOYEES
	GROUP BY JOB_ID
	ORDER BY MAX(SALARY) DESC;

-- 7. MANAGER_ID가 145인 EMPLOYEE의 수와 SALARY의 평균을 구하기
SELECT MANAGER_ID, COUNT(*) EMPLOYEE_CNT, AVG(SALARY) FROM EMPLOYEES
	WHERE MANAGER_ID = 145
	GROUP BY MANAGER_ID
	ORDER BY EMPLOYEE_CNT;

-- 8. EMPLOYEE의 수가 10명 미만인 각 DEPARTMENT의 DEPARTMENT_ID와 소속 EMPLOYEE 수 구하기 (COUNT 오름차순 정렬)
SELECT DEPARTMENT_ID, COUNT(*) EMPLOYEE_CNT FROM EMPLOYEES e
	GROUP BY DEPARTMENT_ID
	HAVING COUNT(*) < 10
	ORDER BY EMPLOYEE_CNT;

-- 9. DEPARTMENT_NAME에 'IT'가 포함되는 DEPARTMENT 중에서 LOCATION_ID가 1700인 DEPARTMENT의 수 구하기 (대소문자 구별 X)
SELECT LOCATION_ID, COUNT(*) DEPARTMENT_CNT 
	FROM DEPARTMENTS
	WHERE DEPARTMENT_NAME LIKE UPPER('%it%')
	GROUP BY LOCATION_ID
	HAVING LOCATION_ID = 1700
	ORDER BY DEPARTMENT_CNT;

-- 10. HIRE_DATE가 2006-08-01 이후인 EMPLOYEE 중에서 COMMISSION_PCT에 대해 그룹화하여 내림차순으로 정렬하고, 
--		각 그룹에 대한 EMPLOYEES의 수와 최저 SALARY 구하기 (COMMISSION_PCT가 NULL인 그룹은 제외한다.)
SELECT COMMISSION_PCT, COUNT(*) EMPLOYEE_CNT, MIN(SALARY) FROM EMPLOYEES
	WHERE HIRE_DATE >= '2006-08-01'
	GROUP BY COMMISSION_PCT
	HAVING COMMISSION_PCT IS NOT NULL
	ORDER BY COMMISSION_PCT DESC;
	
-- 그룹화를 하고, JOIN을 한다? 어렵네 이건... JOIN을 하고 그룹화하는 건 되는군!

